/*
 * vim: set sw=4 sts=4:
 *
 * MIT License Copyright (C) 2017 Hiroshi Shimamoto
 *
 * This tool `sshcompile` generates .ssh/config file.
 * The sources for hosts should be placed under .ssh/hosts
 * and identity keys should be placed under .ssh/keys.
 */

package main

import (
    "log"
    "os"
    "bufio"
    "strings"
    "io/ioutil"
    "path/filepath"
)

var KeyMap map[string]string = map[string]string {
    "hostname": "HostName",
    "user": "User",
    "port": "Port",
    "identityfile": "IdentityFile",
    "proxycommand": "ProxyCommand",
    "stricthostkeychecking": "StrictHostKeyChecking",
    "userknownhostfile": "UserKnownHostFile",
    "serveraliveinterval": "ServerAliveInterval",
}

var Home string

type RemoteHost struct {
    Path string
    Top bool
    EntryName string
    Name string
    KeyVal map[string]string
    //
    Children []RemoteHost
}

func (h *RemoteHost)compile() []string {
    var config []string

    if len(h.Children) > 0 {
	for _, child := range h.Children {
	    if child.Top {
		config = append(config, child.compile()...)
		break
	    }
	}
	for _, child := range h.Children {
	    if !child.Top {
		config = append(config, child.compile()...)
		break
	    }
	}
	return config
    }

    // Host
    config = append(config, "Host " + h.Name)

    keys := []string{"user", "hostname", "port", // "identityfile",
		    "proxycommand", "serveraliveinterval",
		    "stricthostkeychecking", "userknownhostfile"}
    for _, key := range keys {
	val, ok := h.KeyVal[key]
	if ok {
	    config = append(config, "  " + KeyMap[key] + " " + val)
	}
    }
    val, ok := h.KeyVal["identityfile"]
    if ok {
	// check identityfile
	idfilepath := Home + ".ssh/keys/" + val
	_, err := os.Stat(idfilepath)
	if err == nil {
	    config = append(config, "  IdentityFile " + idfilepath)
	}
    }

    config = append(config, "")

    return config
}

func createRemoteHost(path string, file os.FileInfo, join chan RemoteHost) {
    host := RemoteHost { Path: path, EntryName: path, Top: false }
    defer func() { join <- host }()
    if file.IsDir() {
	j := make(chan RemoteHost)
	n := walk(path, j)
	for n > 0 {
	    host.Children = append(host.Children, <-j)
	    n--
	}
	return
    }

    _, filename := filepath.Split(path)
    if filename == "_top" {
	host.Top = true
    }
    host.Name = filename
    host.KeyVal = make(map[string]string)

    f, err := os.Open(path)
    if err != nil {
	log.Println("Bad", path, err)
	return
    }
    defer f.Close()

    s := bufio.NewScanner(f)
    for s.Scan() {
	line := strings.TrimSpace(s.Text())
	ar := strings.SplitN(line, " ", 2)
	if len(ar) != 2 {
	    ar = strings.SplitN(line, "\t", 2)
	}
	key := strings.TrimSpace(ar[0])
	val := strings.TrimSpace(ar[1])
	//log.Println(key, "=", val)
	host.KeyVal[strings.ToLower(key)] = val
    }
}

func walk(dir string, join chan RemoteHost) int {
    files, err := ioutil.ReadDir(dir)
    if err != nil {
	log.Println("ReadDir", err)
	return 0
    }

    n := 0
    for _, f := range files {
	go createRemoteHost(filepath.Join(dir, f.Name()), f, join)
	n++
    }

    return n
}

func main() {
    Home = os.Getenv("HOME") + "/"
    dir := Home + ".ssh/hosts"

    join := make(chan RemoteHost)
    n := walk(dir, join)

    var config []string
    for n > 0 {
	host := <-join
	log.Println(host.EntryName)
	config = append(config, host.compile()...)
	n--
    }

    sshconfig, err := os.OpenFile(Home + ".ssh/config", os.O_WRONLY|os.O_CREATE, 0600)
    if err != nil {
	log.Println("Open", err)
	return
    }

    banner :=
	"# THIS FILE WAS GENERATED BY COMPILE PROGRAM\n" +
	"# DO NOT MODIFY DIRECTLY\n\n"

    sshconfig.WriteString(banner)
    sshconfig.WriteString(strings.Join(config, "\n"))
}
